{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AERO Internal Documentation Documentation for system and software development in McGill AERO Design Team Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#aero-internal-documentation","text":"Documentation for system and software development in McGill AERO Design Team","title":"AERO Internal Documentation"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"dev/log_dev/","text":"Logging and analyzing flight logs Logging is the process of collecting flight data or autopilot system data in a log file while the vehicle was airborne. This is the same as what a black box / flight recorder does on an airliner. Flight logs are useful for assessing vehicle performance or tuning PIDs. More importantly, logs allow developers to diagnose a specific issue. Log Collection Logging automatically starts when the vehicle arms, and stopped when it disarms. A new log file is created for each arming session on the SD card. The log file is a binary data file with extension .ulg The uORB topics to be logged can be manually defined using a file on the SD card. Create a file etc/logging/logger_topics.txt (Also reate the etc/logging directory for first time users) and list the required uORB topics in it. Use the format as follows <topic_name>, <interval> Specify logging rate for a topic by specify the interval between two logged messages in milliseconds, in <interval> . If custom uORB topics have been created, specifying it in logger_topics.txt is the best way to ensure the custom flight data is logged. Otherwise, firmware files have to be changed. See Deep Dive below for details Log Analysis PX4\u2019s default log analysis tool is Flight Review, an online utility. It has a set of tools to visualize the flight path, and does a good job recreating the flight experience. Flight Review graphs the following flight data Attitude Estimates Barometric Altitude, GPS Altitude, Fused Altitude Estimation, Thrust Roll / Pitch / Yaw angle Estimate, Setpoint Roll / Pitch / Yaw angular rate Estimate, Setpoint Local Position Estimation X, Y, Z (coordinates) Velocity Estimation X, Y, Z (direction) Manual Control Input Channels 1-8 Actuator Control Command Roll, Pitch, Yaw, Thrust Actuator Control Output Motor 1,2,3,4 Raw acceleration, i.e. Acclerometer measurements Raw angular speed, i.e. Gyro measurements Raw magnetic field strength, i.e. Compass measurements) And some advanced graphs Log parsing with pyulog pyulog is a python package that can parse ulog files and convert or display them. It enables third-party scripts or utilities, such as MATLAB to process ulog files. Install pyulog with pip install pyulog Detailed instructions on using pyulog can be found on its github page. The following are the commands in the package Display information of file: ulog_info Extract messaged from file: ulog_messages Extracting parameters from file: ulog_params Convert ulog to csv: ulog2csv Convert ulog to kml: ulog2kml Deep Dive The PX4 firmware has two modules for logging flight data. sdlog2 : This module is obsolete and it writes logs to .px4log files. Location: src/modules/sdlog2 logger : This module is modern and it writes logs to .ulog files. Location: src/modules/logger sdlog2 hard codes log messages and their data types into the module\u2019s source code. On the other hand, logger collects flight data on a per topic basis, and automatically labels and declares log messages. One important consequence of this change is that while sdlog2 must collect all flight data at the same rate, Logger can collect flight data from different uORB topics at different rates. For example, IMU data which is sampled at 32kHz may be logged at a much higher rate than GPS position data, which is sampled at 10Hz. Logger code To add, remove or customize log messages in source code, only logger.cpp needs to edited in one location as shown below void Logger::add_default_topics() { // Note: try to avoid setting the interval where possible add_topic(\"actuator_controls_0\", 100); /*...*/ add_topic(\"debug\", 100); // This is a custom topic /*...*/ }","title":"Logging and log analysis"},{"location":"dev/log_dev/#logging-and-analyzing-flight-logs","text":"Logging is the process of collecting flight data or autopilot system data in a log file while the vehicle was airborne. This is the same as what a black box / flight recorder does on an airliner. Flight logs are useful for assessing vehicle performance or tuning PIDs. More importantly, logs allow developers to diagnose a specific issue.","title":"Logging and analyzing flight logs"},{"location":"dev/log_dev/#log-collection","text":"Logging automatically starts when the vehicle arms, and stopped when it disarms. A new log file is created for each arming session on the SD card. The log file is a binary data file with extension .ulg The uORB topics to be logged can be manually defined using a file on the SD card. Create a file etc/logging/logger_topics.txt (Also reate the etc/logging directory for first time users) and list the required uORB topics in it. Use the format as follows <topic_name>, <interval> Specify logging rate for a topic by specify the interval between two logged messages in milliseconds, in <interval> . If custom uORB topics have been created, specifying it in logger_topics.txt is the best way to ensure the custom flight data is logged. Otherwise, firmware files have to be changed. See Deep Dive below for details","title":"Log Collection"},{"location":"dev/log_dev/#log-analysis","text":"PX4\u2019s default log analysis tool is Flight Review, an online utility. It has a set of tools to visualize the flight path, and does a good job recreating the flight experience. Flight Review graphs the following flight data Attitude Estimates Barometric Altitude, GPS Altitude, Fused Altitude Estimation, Thrust Roll / Pitch / Yaw angle Estimate, Setpoint Roll / Pitch / Yaw angular rate Estimate, Setpoint Local Position Estimation X, Y, Z (coordinates) Velocity Estimation X, Y, Z (direction) Manual Control Input Channels 1-8 Actuator Control Command Roll, Pitch, Yaw, Thrust Actuator Control Output Motor 1,2,3,4 Raw acceleration, i.e. Acclerometer measurements Raw angular speed, i.e. Gyro measurements Raw magnetic field strength, i.e. Compass measurements) And some advanced graphs","title":"Log Analysis"},{"location":"dev/log_dev/#log-parsing-with-pyulog","text":"pyulog is a python package that can parse ulog files and convert or display them. It enables third-party scripts or utilities, such as MATLAB to process ulog files. Install pyulog with pip install pyulog Detailed instructions on using pyulog can be found on its github page. The following are the commands in the package Display information of file: ulog_info Extract messaged from file: ulog_messages Extracting parameters from file: ulog_params Convert ulog to csv: ulog2csv Convert ulog to kml: ulog2kml","title":"Log parsing with pyulog"},{"location":"dev/log_dev/#deep-dive","text":"The PX4 firmware has two modules for logging flight data. sdlog2 : This module is obsolete and it writes logs to .px4log files. Location: src/modules/sdlog2 logger : This module is modern and it writes logs to .ulog files. Location: src/modules/logger sdlog2 hard codes log messages and their data types into the module\u2019s source code. On the other hand, logger collects flight data on a per topic basis, and automatically labels and declares log messages. One important consequence of this change is that while sdlog2 must collect all flight data at the same rate, Logger can collect flight data from different uORB topics at different rates. For example, IMU data which is sampled at 32kHz may be logged at a much higher rate than GPS position data, which is sampled at 10Hz.","title":"Deep Dive"},{"location":"dev/log_dev/#logger-code","text":"To add, remove or customize log messages in source code, only logger.cpp needs to edited in one location as shown below void Logger::add_default_topics() { // Note: try to avoid setting the interval where possible add_topic(\"actuator_controls_0\", 100); /*...*/ add_topic(\"debug\", 100); // This is a custom topic /*...*/ }","title":"Logger code"},{"location":"dev/mavlink_dev/","text":"MAVLink Development The objective of MAVLink messaging is to send data to QGroundControl GCS for inspection/visualization. Internally, flight data is handled as uORB messages. In our case, this message is pot_angle as defined in msg/pot_angle.msg . Create custom mavlink message For MAVLink communication, a corresponding MAVLink message pot_angle should be created. This message is defined in an .xml file in mavlink/include/mavlink/v2.0/message_definitions and then converted to C/C++ code. MAVLink is a submodule in PX4 firmware! Use git submodule update --init --recursive to fetch it. Unfortunately, this means the edited MAVLink library and included headers is not pushed to the Firmware repository. Please follow the direction below to generate MAVLink headers custom_msgs.xml is the .xml message definition for pot_angle shown below <?xml version=\"1.0\"?> <mavlink> <include>common.xml</include> <include>ardupilotmega.xml</include> <version>3</version> <messages> <message id=\"190\" name=\"POT_ANGLE\"> <description>Potentiometer readings</description> <field type=\"uint64_t\" name=\"error_count\">Number of errors detected by driver</field> <field type=\"float\" name=\"pot_ADCraw\">Raw ADC reading</field> <field type=\"float\" name=\"pot_angle_deg_raw\" units=\"deg\">unfiltered angle</field> <field type=\"float\" name=\"pot_angle_deg\" units=\"deg\">filtered angle in degrees</field> <field type=\"float\" name=\"pot_angle_rad\" units=\"rad\">filtered angle in radians</field> <field type=\"float\" name=\"pot_rate_deg_raw\" units=\"deg\">unfiltered angle rate in degrees</field> <field type=\"float\" name=\"pot_rate_deg\" units=\"deg\"> filtered rate in degrees</field> <field type=\"float\" name=\"pot_rate_rad\" units=\"rad\"> filtered rate in radians</field> <field type=\"float\" name=\"pot_dt\"></field> </message> </messages> </mavlink> XML Definitions <message></message> : Encapsulates one message id=\u201c190\u201d : Index number of the message. In general, id 150-240 is reserved for custom messages <description></description> : Describes the message, and will be converted into comments during C/C++ code generation <field></field> : Encodes one field of the message type=\u201cfloat\u201d Defines data type of the field Compiling XML to C/C++ The message definition is compiled into C/C++ code for use by the autopilot by a python script mavgenerate.py . This script is part of the Mavlink Repository . Clone the repo and run python mavgenerate.py to bring up a GUI for configuring code generation. XML: .xml file of message definition Out: Output directory, generally set to be mavlink/include/mavlink/v2.0 . Code generation will create a new folder in this directory to contain the message headers. Language: Use C++11 for PX4 Firmware and QGroundControl mavlink libraty Validate/Validate Units: Manually check your .xml definition, and omit validation to avoid getting spurious errors Sending custom MAVLink messages Sending and receiving MAVLink messages is mostly handled in the various C/C++ files in src/modules/mavlink . A class for the message should be created in mavlink_messages.cpp . First, add the headers of the uORB and mavlink messages. #include <uORB/topics/pot_angle.h> #include <v2.0/custom_msgs/mavlink_msg_pot_angle.h> Then create the class class MavlinkStreamPotAngle : public MavlinkStream { public: const char *get_name() const { return MavlinkStreamPotAngle::get_name_static(); } static const char *get_name_static() { return \"POT_ANGLE\"; } static uint16_t get_id_static() { return MAVLINK_MSG_ID_POT_ANGLE; } uint16_t get_id() { return get_id_static(); } static MavlinkStream *new_instance(Mavlink *mavlink) { return new MavlinkStreamPotAngle(mavlink); } unsigned get_size() { return MAVLINK_MSG_ID_POT_ANGLE_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES; } private: MavlinkOrbSubscription *_sub; uint64_t _pot_time; /* do not allow top copying this class */ MavlinkStreamPotAngle(MavlinkStreamPotAngle &); MavlinkStreamPotAngle& operator = (const MavlinkStreamPotAngle &); protected: explicit MavlinkStreamPotAngle(Mavlink *mavlink) : MavlinkStream(mavlink), _sub(_mavlink->add_orb_subscription(ORB_ID(pot_angle))), // make sure you enter the name of your uORB topic here _pot_time(0) {} bool send(const hrt_abstime t) { pot_angle_s _pot_angle; if (_sub->update(&_pot_time, &_pot_angle)) { mavlink_pot_angle_t msg = {}; //make sure mavlink_pot_angle_t is the definition of your custom MAVLink message msg.error_count = _pot_angle.error_count; msg.pot_ADCraw = _pot_angle.pot_ADCraw; msg.pot_angle_deg_raw = _pot_angle.pot_angle_deg_raw; msg.pot_angle_deg = _pot_angle.pot_angle_deg; msg.pot_angle_rad = _pot_angle.pot_angle_rad; msg.pot_rate_deg_raw = _pot_angle.pot_rate_deg_raw; msg.pot_rate_deg = _pot_angle.pot_rate_deg; msg.pot_rate_rad = _pot_angle.pot_rate_rad; msg.pot_dt = _pot_angle.pot_dt; mavlink_msg_pot_angle_send_struct(_mavlink->get_channel(), &msg); return true; } return false; } }; Finally append the stream class to the streams_list at the bottom of the code. static const StreamListItem streams_list[] = { StreamListItem(&MavlinkStreamPotAngle::new_instance, &MavlinkStreamPotAngle::get_name_static, &MavlinkStreamPotAngle::get_id_static), } Enabling the MAVLink stream To enable the MAVLink stream, edit mavlink_main.cpp and add relevant messages to configure_streams_to_default . First include the MAVLink message header in mavlink_main.h #include <v2.0/custom_msgs/mavlink_msg_pot_angle.h> Then append the configure function to each case matching a MAVLink mode in which the MAVLink stream should be enabled case MAVLINK_MODE_NORMAL: configure_stream_local(\"POT_ANGLE\", 10.0f); break; Alternately, add a line to the startup script extras.txt on the SD card to enable the streaming. mavlink stream -r 50 -s POT_ANGLE -d /dev/ttyACM0 Parameters are -r , -s and -d , which configures the data rate, MAVLink message, and serial port of the stream. Reading the MAVLink Stream To read the MAVLink Stream, QGroundControl should be rebuilt with the custom MAVLink message headers. This simply entails repeating the steps in the above section Creating custom MAVLink message in qgroundcontrol/libs/mavlink/include/mavlink/v2.0 MAVLink is a submodule in QGroundControl firmware too The composition of the .xml message definition becomes important here. <include>common.xml</include> <include>ardupilotmega.xml</include> Both common.xml and ardupilotmega.xml definitions must be included. The latter is a superset of all MAVLink messages and has an include line for common.xml within it. However, C++ code generation omits nested includes. Hence, both .xml files must be included, and omission of either will break the build. Configuring QGroundControl build Add a file user_config.pri in the QGroundControl base directory and enter the following line. MAVLINK_CONF = custom_msgs This will tell QGroundControl to build the customized MAVLink library.","title":"Mavlink Development"},{"location":"dev/mavlink_dev/#mavlink-development","text":"The objective of MAVLink messaging is to send data to QGroundControl GCS for inspection/visualization. Internally, flight data is handled as uORB messages. In our case, this message is pot_angle as defined in msg/pot_angle.msg .","title":"MAVLink Development"},{"location":"dev/mavlink_dev/#create-custom-mavlink-message","text":"For MAVLink communication, a corresponding MAVLink message pot_angle should be created. This message is defined in an .xml file in mavlink/include/mavlink/v2.0/message_definitions and then converted to C/C++ code. MAVLink is a submodule in PX4 firmware! Use git submodule update --init --recursive to fetch it. Unfortunately, this means the edited MAVLink library and included headers is not pushed to the Firmware repository. Please follow the direction below to generate MAVLink headers custom_msgs.xml is the .xml message definition for pot_angle shown below <?xml version=\"1.0\"?> <mavlink> <include>common.xml</include> <include>ardupilotmega.xml</include> <version>3</version> <messages> <message id=\"190\" name=\"POT_ANGLE\"> <description>Potentiometer readings</description> <field type=\"uint64_t\" name=\"error_count\">Number of errors detected by driver</field> <field type=\"float\" name=\"pot_ADCraw\">Raw ADC reading</field> <field type=\"float\" name=\"pot_angle_deg_raw\" units=\"deg\">unfiltered angle</field> <field type=\"float\" name=\"pot_angle_deg\" units=\"deg\">filtered angle in degrees</field> <field type=\"float\" name=\"pot_angle_rad\" units=\"rad\">filtered angle in radians</field> <field type=\"float\" name=\"pot_rate_deg_raw\" units=\"deg\">unfiltered angle rate in degrees</field> <field type=\"float\" name=\"pot_rate_deg\" units=\"deg\"> filtered rate in degrees</field> <field type=\"float\" name=\"pot_rate_rad\" units=\"rad\"> filtered rate in radians</field> <field type=\"float\" name=\"pot_dt\"></field> </message> </messages> </mavlink>","title":"Create custom mavlink message"},{"location":"dev/mavlink_dev/#xml-definitions","text":"<message></message> : Encapsulates one message id=\u201c190\u201d : Index number of the message. In general, id 150-240 is reserved for custom messages <description></description> : Describes the message, and will be converted into comments during C/C++ code generation <field></field> : Encodes one field of the message type=\u201cfloat\u201d Defines data type of the field","title":"XML Definitions"},{"location":"dev/mavlink_dev/#compiling-xml-to-cc","text":"The message definition is compiled into C/C++ code for use by the autopilot by a python script mavgenerate.py . This script is part of the Mavlink Repository . Clone the repo and run python mavgenerate.py to bring up a GUI for configuring code generation. XML: .xml file of message definition Out: Output directory, generally set to be mavlink/include/mavlink/v2.0 . Code generation will create a new folder in this directory to contain the message headers. Language: Use C++11 for PX4 Firmware and QGroundControl mavlink libraty Validate/Validate Units: Manually check your .xml definition, and omit validation to avoid getting spurious errors","title":"Compiling XML to C/C++"},{"location":"dev/mavlink_dev/#sending-custom-mavlink-messages","text":"Sending and receiving MAVLink messages is mostly handled in the various C/C++ files in src/modules/mavlink . A class for the message should be created in mavlink_messages.cpp . First, add the headers of the uORB and mavlink messages. #include <uORB/topics/pot_angle.h> #include <v2.0/custom_msgs/mavlink_msg_pot_angle.h> Then create the class class MavlinkStreamPotAngle : public MavlinkStream { public: const char *get_name() const { return MavlinkStreamPotAngle::get_name_static(); } static const char *get_name_static() { return \"POT_ANGLE\"; } static uint16_t get_id_static() { return MAVLINK_MSG_ID_POT_ANGLE; } uint16_t get_id() { return get_id_static(); } static MavlinkStream *new_instance(Mavlink *mavlink) { return new MavlinkStreamPotAngle(mavlink); } unsigned get_size() { return MAVLINK_MSG_ID_POT_ANGLE_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES; } private: MavlinkOrbSubscription *_sub; uint64_t _pot_time; /* do not allow top copying this class */ MavlinkStreamPotAngle(MavlinkStreamPotAngle &); MavlinkStreamPotAngle& operator = (const MavlinkStreamPotAngle &); protected: explicit MavlinkStreamPotAngle(Mavlink *mavlink) : MavlinkStream(mavlink), _sub(_mavlink->add_orb_subscription(ORB_ID(pot_angle))), // make sure you enter the name of your uORB topic here _pot_time(0) {} bool send(const hrt_abstime t) { pot_angle_s _pot_angle; if (_sub->update(&_pot_time, &_pot_angle)) { mavlink_pot_angle_t msg = {}; //make sure mavlink_pot_angle_t is the definition of your custom MAVLink message msg.error_count = _pot_angle.error_count; msg.pot_ADCraw = _pot_angle.pot_ADCraw; msg.pot_angle_deg_raw = _pot_angle.pot_angle_deg_raw; msg.pot_angle_deg = _pot_angle.pot_angle_deg; msg.pot_angle_rad = _pot_angle.pot_angle_rad; msg.pot_rate_deg_raw = _pot_angle.pot_rate_deg_raw; msg.pot_rate_deg = _pot_angle.pot_rate_deg; msg.pot_rate_rad = _pot_angle.pot_rate_rad; msg.pot_dt = _pot_angle.pot_dt; mavlink_msg_pot_angle_send_struct(_mavlink->get_channel(), &msg); return true; } return false; } }; Finally append the stream class to the streams_list at the bottom of the code. static const StreamListItem streams_list[] = { StreamListItem(&MavlinkStreamPotAngle::new_instance, &MavlinkStreamPotAngle::get_name_static, &MavlinkStreamPotAngle::get_id_static), }","title":"Sending custom MAVLink messages"},{"location":"dev/mavlink_dev/#enabling-the-mavlink-stream","text":"To enable the MAVLink stream, edit mavlink_main.cpp and add relevant messages to configure_streams_to_default . First include the MAVLink message header in mavlink_main.h #include <v2.0/custom_msgs/mavlink_msg_pot_angle.h> Then append the configure function to each case matching a MAVLink mode in which the MAVLink stream should be enabled case MAVLINK_MODE_NORMAL: configure_stream_local(\"POT_ANGLE\", 10.0f); break; Alternately, add a line to the startup script extras.txt on the SD card to enable the streaming. mavlink stream -r 50 -s POT_ANGLE -d /dev/ttyACM0 Parameters are -r , -s and -d , which configures the data rate, MAVLink message, and serial port of the stream.","title":"Enabling the MAVLink stream"},{"location":"dev/mavlink_dev/#reading-the-mavlink-stream","text":"To read the MAVLink Stream, QGroundControl should be rebuilt with the custom MAVLink message headers. This simply entails repeating the steps in the above section Creating custom MAVLink message in qgroundcontrol/libs/mavlink/include/mavlink/v2.0 MAVLink is a submodule in QGroundControl firmware too The composition of the .xml message definition becomes important here. <include>common.xml</include> <include>ardupilotmega.xml</include> Both common.xml and ardupilotmega.xml definitions must be included. The latter is a superset of all MAVLink messages and has an include line for common.xml within it. However, C++ code generation omits nested includes. Hence, both .xml files must be included, and omission of either will break the build.","title":"Reading the MAVLink Stream"},{"location":"dev/mavlink_dev/#configuring-qgroundcontrol-build","text":"Add a file user_config.pri in the QGroundControl base directory and enter the following line. MAVLINK_CONF = custom_msgs This will tell QGroundControl to build the customized MAVLink library.","title":"Configuring QGroundControl build"},{"location":"ref/airframe_ref/","text":"Airframe Unmanned Air Vehicles (UAVs) is a broad term that encompass a wide variety of aircraft. In practice, UAVs are commonly grouped in three classes Multicopters: Versatile, manoeuvrable, and capable of precise hovering, but limited in endurance or range Fixed-Wings: Traditional planes are very efficient, and can easily achieve high speed or long distance flight VTOLs: Vertical-Takeoff-Or-Landing aircraft combines the benefits of fixed-wing planes and multicopters QGroundControl airframe selection screen Understanding different types of UAVs helps you choose/design an aircraft for the intended application. Once you have prepared your aircraft, the PX4 firmware must be matched to it in order to control it Multicopters Multicopters use multiple motors driving propellers to achieve lift. They manoeuvre in the air by adjusting motor speeds, i.e. motor differentials. Tricopter The Tricopter has 3 motors and a servo to tilt the axial motor to counteract a net motor torque imbalance. Tricopters were popular earlier, when motors were unreliable Performance is limited, and may not scale well to larger sizes Due to their use of a servo, they are difficult to setup and maintain. Quadcopter The quadcopter uses 4 motors Symmetric geometry makes for simple flight dynamics. Suitable for a wide range of applications, as they can be scaled up to larger sizes, and can carry diverse payloads Primary drawback is a lack of redundancy: Failure of even one single motor will cause total loss of control. Quadcopter configurations and designations Quadcopter X: Frame arms linked at the center of the airframe in X-shape. Most common configuration Quadcopter +: Frame arms are aligned to the body axes, such that four arms form a plus shape. Unpopular because the front motor blocks forward looking cameras. Quadcopter Wide: Based on Quadcopter X, with front arms spread apart to give a wide field of view to a forward looking camera. Quadcopter H: Based on Quadcopter X, with frame arms built from single horizontal booms. Robust configuration that is especially easy to construct with basic craftsmanship. Hexacopter and Octocopter The hexacopter uses six motors, while the octocopter uses eight. Stable heavy-lifter configuration, widely used for aerial photography and agricultural applications Motor redundancy allows vehicle to remain airborne after one motor is disabled Primary drawback is inefficiency: Not suitable for long-range or high-speed applications Hexa/Octocopter Coaxial (Y6 and X8) Variations on the hexacopter and octocopter respectively, mounting two motors co-axially on each frame arm in a contra-rotating configuration. (e.g. upper motor CCW, lower motor CW) Very stable and geometrically compact configuration that makes for mechanical simplicity and high payload capacity Primary drawback is inefficiency: Approx. 10% penalty in propulsive efficiency compared to a hexacopter or octocopter. VTOLs VTOL aircraft usually combine a multicopter configuration with wings to achieve Vertical-Takeoff-Or-Landing while retaining the efficiency of fixed-wings. Tailsitter The tailsitter mounts two tractor motors on a flying wing. In fixed-wing mode, they fly like a simple twin-engine plane. In multicopter mode, the flying wing is oriented vertically, such that the motors thrust up for lift, and the wing ailerons redirect slipstream air for lateral control. Mechanically simplest way to achieve Vertical-Takeoff-Or-Landing. Primary drawback is unwieldiness: They take off nose vertically up but flies level, making payload mounting very complicated Tiltrotor The tiltrotor mounts two motors that can tilt up, plus one tail motor to provide stabilization during the motor-tilting process. Short wings provide lift during forward-flight. Efficient and versatile VTOL configuration that combines many valuable features of multicopters and planes Primary drawback is unreliability: The tiltrotor mechanism is complex, and the VTOL transition, during which the motor tilts, is hard to control Quadplane The quadplane mounts four motors in a Quadcopter X configurations to a fixed wing plane, which also has a motor for propulsion Most reliable VTOL configuration that uses no moving actuators or changing vehicle orientation in flight. Primary drawback is inefficiency: quadcopter motors are useless in fixed-wing mode, and plane motor is useless in multicopter mode","title":"Vehicles and Airframes"},{"location":"ref/airframe_ref/#airframe","text":"Unmanned Air Vehicles (UAVs) is a broad term that encompass a wide variety of aircraft. In practice, UAVs are commonly grouped in three classes Multicopters: Versatile, manoeuvrable, and capable of precise hovering, but limited in endurance or range Fixed-Wings: Traditional planes are very efficient, and can easily achieve high speed or long distance flight VTOLs: Vertical-Takeoff-Or-Landing aircraft combines the benefits of fixed-wing planes and multicopters QGroundControl airframe selection screen Understanding different types of UAVs helps you choose/design an aircraft for the intended application. Once you have prepared your aircraft, the PX4 firmware must be matched to it in order to control it","title":"Airframe"},{"location":"ref/airframe_ref/#multicopters","text":"Multicopters use multiple motors driving propellers to achieve lift. They manoeuvre in the air by adjusting motor speeds, i.e. motor differentials.","title":"Multicopters"},{"location":"ref/airframe_ref/#tricopter","text":"The Tricopter has 3 motors and a servo to tilt the axial motor to counteract a net motor torque imbalance. Tricopters were popular earlier, when motors were unreliable Performance is limited, and may not scale well to larger sizes Due to their use of a servo, they are difficult to setup and maintain.","title":"Tricopter"},{"location":"ref/airframe_ref/#quadcopter","text":"The quadcopter uses 4 motors Symmetric geometry makes for simple flight dynamics. Suitable for a wide range of applications, as they can be scaled up to larger sizes, and can carry diverse payloads Primary drawback is a lack of redundancy: Failure of even one single motor will cause total loss of control.","title":"Quadcopter"},{"location":"ref/airframe_ref/#quadcopter-configurations-and-designations","text":"Quadcopter X: Frame arms linked at the center of the airframe in X-shape. Most common configuration Quadcopter +: Frame arms are aligned to the body axes, such that four arms form a plus shape. Unpopular because the front motor blocks forward looking cameras. Quadcopter Wide: Based on Quadcopter X, with front arms spread apart to give a wide field of view to a forward looking camera. Quadcopter H: Based on Quadcopter X, with frame arms built from single horizontal booms. Robust configuration that is especially easy to construct with basic craftsmanship.","title":"Quadcopter configurations and designations"},{"location":"ref/airframe_ref/#hexacopter-and-octocopter","text":"The hexacopter uses six motors, while the octocopter uses eight. Stable heavy-lifter configuration, widely used for aerial photography and agricultural applications Motor redundancy allows vehicle to remain airborne after one motor is disabled Primary drawback is inefficiency: Not suitable for long-range or high-speed applications","title":"Hexacopter and Octocopter"},{"location":"ref/airframe_ref/#hexaoctocopter-coaxial-y6-and-x8","text":"Variations on the hexacopter and octocopter respectively, mounting two motors co-axially on each frame arm in a contra-rotating configuration. (e.g. upper motor CCW, lower motor CW) Very stable and geometrically compact configuration that makes for mechanical simplicity and high payload capacity Primary drawback is inefficiency: Approx. 10% penalty in propulsive efficiency compared to a hexacopter or octocopter.","title":"Hexa/Octocopter Coaxial (Y6 and X8)"},{"location":"ref/airframe_ref/#vtols","text":"VTOL aircraft usually combine a multicopter configuration with wings to achieve Vertical-Takeoff-Or-Landing while retaining the efficiency of fixed-wings.","title":"VTOLs"},{"location":"ref/airframe_ref/#tailsitter","text":"The tailsitter mounts two tractor motors on a flying wing. In fixed-wing mode, they fly like a simple twin-engine plane. In multicopter mode, the flying wing is oriented vertically, such that the motors thrust up for lift, and the wing ailerons redirect slipstream air for lateral control. Mechanically simplest way to achieve Vertical-Takeoff-Or-Landing. Primary drawback is unwieldiness: They take off nose vertically up but flies level, making payload mounting very complicated","title":"Tailsitter"},{"location":"ref/airframe_ref/#tiltrotor","text":"The tiltrotor mounts two motors that can tilt up, plus one tail motor to provide stabilization during the motor-tilting process. Short wings provide lift during forward-flight. Efficient and versatile VTOL configuration that combines many valuable features of multicopters and planes Primary drawback is unreliability: The tiltrotor mechanism is complex, and the VTOL transition, during which the motor tilts, is hard to control","title":"Tiltrotor"},{"location":"ref/airframe_ref/#quadplane","text":"The quadplane mounts four motors in a Quadcopter X configurations to a fixed wing plane, which also has a motor for propulsion Most reliable VTOL configuration that uses no moving actuators or changing vehicle orientation in flight. Primary drawback is inefficiency: quadcopter motors are useless in fixed-wing mode, and plane motor is useless in multicopter mode","title":"Quadplane"},{"location":"ref/autopilot_ref/","text":"Autopilot Hardware Reference Pixhawk series autopilots all run PX4 or ArduPilot firmware, but the hardware differ in interfaces and form factor. This section summarizes the available autopilot hardware and groups them into three categories. General purpose autopilots These are full-feature autopilots with a full set of interfaces, i.e. 8+6 Main and Aux outputs, 5 serial ports, analog ports. They are suitable for a wide range of airframes and configurations. They can further be categorized by their intended applications. Industrial / Commercial These are well tested and widely available at a reasonable price. They are optimized for easy deployment on industrial or professional UAVs. Pixhawk Pixhawk 2.1 mRo X2.1 Academic / Research These are computationally powerful and feature-rich, and accordingly more expensive. They are good platforms for developing bleeding-edge capabilities Pixhawk 3 Pro Pixhawk 4 Miniaturized Autopilots These are small and lightweight autopilots with a reduced set of interfaces. They are suitable for space-constrained configurations, e.g. microquads and racers. Pixhawk Mini Pixracer Derivatives These are derivatives of one of the above designs. They are less well tested, but retain the set of features and capabilities of their parent design. Dropix Pixhack MindPX Linux Based These consist of a sensor / processor shield that interfaces with a Raspberry Pi single-board computer. They are very computationally powerful, and lends itself well to customized applications, APIs, or complicated tasks such as computer vision. Warning: Linux based autopilots are considerably more difficult to setup. Consider setting up a Linux based autopilot as configuring both a Raspberry Pi AND a traditional autopilot. Warning: Exotic designs are excluded from this list. It is the end-user\u2019s responsibility to find them and verify their capabilities.","title":"Autopilot Hardware"},{"location":"ref/autopilot_ref/#autopilot-hardware-reference","text":"Pixhawk series autopilots all run PX4 or ArduPilot firmware, but the hardware differ in interfaces and form factor. This section summarizes the available autopilot hardware and groups them into three categories.","title":"Autopilot Hardware Reference"},{"location":"ref/autopilot_ref/#general-purpose-autopilots","text":"These are full-feature autopilots with a full set of interfaces, i.e. 8+6 Main and Aux outputs, 5 serial ports, analog ports. They are suitable for a wide range of airframes and configurations. They can further be categorized by their intended applications.","title":"General purpose autopilots"},{"location":"ref/autopilot_ref/#industrial-commercial","text":"These are well tested and widely available at a reasonable price. They are optimized for easy deployment on industrial or professional UAVs. Pixhawk Pixhawk 2.1 mRo X2.1","title":"Industrial / Commercial"},{"location":"ref/autopilot_ref/#academic-research","text":"These are computationally powerful and feature-rich, and accordingly more expensive. They are good platforms for developing bleeding-edge capabilities Pixhawk 3 Pro Pixhawk 4","title":"Academic / Research"},{"location":"ref/autopilot_ref/#miniaturized-autopilots","text":"These are small and lightweight autopilots with a reduced set of interfaces. They are suitable for space-constrained configurations, e.g. microquads and racers. Pixhawk Mini Pixracer","title":"Miniaturized Autopilots"},{"location":"ref/autopilot_ref/#derivatives","text":"These are derivatives of one of the above designs. They are less well tested, but retain the set of features and capabilities of their parent design. Dropix Pixhack MindPX","title":"Derivatives"},{"location":"ref/autopilot_ref/#linux-based","text":"These consist of a sensor / processor shield that interfaces with a Raspberry Pi single-board computer. They are very computationally powerful, and lends itself well to customized applications, APIs, or complicated tasks such as computer vision. Warning: Linux based autopilots are considerably more difficult to setup. Consider setting up a Linux based autopilot as configuring both a Raspberry Pi AND a traditional autopilot. Warning: Exotic designs are excluded from this list. It is the end-user\u2019s responsibility to find them and verify their capabilities.","title":"Linux Based"},{"location":"ref/sensor_ref/","text":"Sensors A flight control system uses sensors to obtain information on vehicle state in order to perform its primary functions of stabilization and/or navigation. The vehicle states include: Attitude Body rotation rates Position Heading Altitude Speed / Airspeed The flight control system minimally requires an inertial measurement unit (IMU) to for stable flight. Secondly, a compass and a barometer is required to enable some assisted modes. Lastly, a GPS is required to enable fully autonomous modes. Core Sensors IMU The IMU consists of a gyroscope and an accelerometer. This is the most important sensor integral in every autopilot. It measures the vehicle\u2019s angular rates and attitude, and enables the autopilot to perform basic flight stabilization. Compass The compass / magnetometer measures the vehicle\u2019s heading relative to the earth. It enables the autopilot to control vehicle heading during autonomous navigation. Warning: The compass is sensitive to electromagnetic interference (EMI). It must be calibrated carefully to avoid poor performance in auto-modes! Barometer The barometer measures the vehicle's elevation. It enables the autopilot to control vehicle altitude during altitude-hold mode or autonomous navigation. Warning: The barometer is sensitive to pressure change unrelated to elevation change (wind gusts) and changing of lighting conditions. It must be shielded by foam to prevent vehicle climbing and falling unpredictably. Advanced/External Sensors GPS The GPS enables the autopilot to sense the vehicle\u2019s geographic location, i.e. position estimation. It is necessary for holding a fixed vehicle position and navigation in automatic flight modes. Additional information: Main components in a GPS module include the ceramic antenna, the GPS chip, and a compass chip which serves as an external compass Warning: It is strongly advised to mount the GPS module above the UAV on a tall mast. This isolates the GPS chip and the compass chip from electromagnetic interference (EMI) and improves navigation performance Airspeed Sensor (Pitot tube) Airspeed sensor measures the speed of a fixed-wing aircraft relative to surrounding airflow, as opposed to speed measured relative to the ground. It is necessary for all fixed-wing aircraft to maintain lift (and avoid stalling) Optional Sensors Rangefinder Sonar / LIDAR rangefinders provide distance measurements. It enables very precise altitude control (error in the order of cm), terrain-following, or collision avoidance. Sonar rangefinders have very limited range, using LIDAR is recommended. Optical Flow Optical flow uses a downward facing camera for position recognition. It enables position estimation without using GPS, or in a GPS-deprived environment, i.e. indoors / poor weather. Optical flow sensors must be used together with a rangefinder. RTK GPS RTK GPS relies on a 'Base GPS' on the ground to send real-time position correction to a 'Rover GPS' in the air to realize very precise position estimation (error in the order of 10cms)","title":"Sensors"},{"location":"ref/sensor_ref/#sensors","text":"A flight control system uses sensors to obtain information on vehicle state in order to perform its primary functions of stabilization and/or navigation. The vehicle states include: Attitude Body rotation rates Position Heading Altitude Speed / Airspeed The flight control system minimally requires an inertial measurement unit (IMU) to for stable flight. Secondly, a compass and a barometer is required to enable some assisted modes. Lastly, a GPS is required to enable fully autonomous modes.","title":"Sensors"},{"location":"ref/sensor_ref/#core-sensors","text":"","title":"Core Sensors"},{"location":"ref/sensor_ref/#imu","text":"The IMU consists of a gyroscope and an accelerometer. This is the most important sensor integral in every autopilot. It measures the vehicle\u2019s angular rates and attitude, and enables the autopilot to perform basic flight stabilization.","title":"IMU"},{"location":"ref/sensor_ref/#compass","text":"The compass / magnetometer measures the vehicle\u2019s heading relative to the earth. It enables the autopilot to control vehicle heading during autonomous navigation. Warning: The compass is sensitive to electromagnetic interference (EMI). It must be calibrated carefully to avoid poor performance in auto-modes!","title":"Compass"},{"location":"ref/sensor_ref/#barometer","text":"The barometer measures the vehicle's elevation. It enables the autopilot to control vehicle altitude during altitude-hold mode or autonomous navigation. Warning: The barometer is sensitive to pressure change unrelated to elevation change (wind gusts) and changing of lighting conditions. It must be shielded by foam to prevent vehicle climbing and falling unpredictably.","title":"Barometer"},{"location":"ref/sensor_ref/#advancedexternal-sensors","text":"","title":"Advanced/External Sensors"},{"location":"ref/sensor_ref/#gps","text":"The GPS enables the autopilot to sense the vehicle\u2019s geographic location, i.e. position estimation. It is necessary for holding a fixed vehicle position and navigation in automatic flight modes. Additional information: Main components in a GPS module include the ceramic antenna, the GPS chip, and a compass chip which serves as an external compass Warning: It is strongly advised to mount the GPS module above the UAV on a tall mast. This isolates the GPS chip and the compass chip from electromagnetic interference (EMI) and improves navigation performance","title":"GPS"},{"location":"ref/sensor_ref/#airspeed-sensor-pitot-tube","text":"Airspeed sensor measures the speed of a fixed-wing aircraft relative to surrounding airflow, as opposed to speed measured relative to the ground. It is necessary for all fixed-wing aircraft to maintain lift (and avoid stalling)","title":"Airspeed Sensor (Pitot tube)"},{"location":"ref/sensor_ref/#optional-sensors","text":"","title":"Optional Sensors"},{"location":"ref/sensor_ref/#rangefinder","text":"Sonar / LIDAR rangefinders provide distance measurements. It enables very precise altitude control (error in the order of cm), terrain-following, or collision avoidance. Sonar rangefinders have very limited range, using LIDAR is recommended.","title":"Rangefinder"},{"location":"ref/sensor_ref/#optical-flow","text":"Optical flow uses a downward facing camera for position recognition. It enables position estimation without using GPS, or in a GPS-deprived environment, i.e. indoors / poor weather. Optical flow sensors must be used together with a rangefinder.","title":"Optical Flow"},{"location":"ref/sensor_ref/#rtk-gps","text":"RTK GPS relies on a 'Base GPS' on the ground to send real-time position correction to a 'Rover GPS' in the air to realize very precise position estimation (error in the order of 10cms)","title":"RTK GPS"},{"location":"ref/wiring_ref/","text":"Mount and Orient Autopilot Position the autopilot as close to the vehicle\u2019s center of gravity as possible. Ideally, the autopilot should be mounted in the standard orientation, indicated by the heading mark arrow visible on top and pointing towards the front of the vehicle. To mount the pixhawk in a non-standard orientation, configure the pixhawk firmware to recognize the new orientation. This adjusts sensors readings to realign with the vehicle. The pixhawk should be mounted on vibration absorbing material, which isolates the sensitive sensors in the Pixhawk from vibrations. Soft foam such as 3M Pixhawk Damping Foams, gel pads, and mounting tables with rubber damping balls are effective. Powering the autopilot Connect the output port of a power module to the power port of the Pixhawk with a 6-wire cable. A power module supplies stable and filtered power at 5.4V for the pixhawk, measures battery voltage and/or current drawn from the battery. The power module can supply power to the autopilot, radio receiver, and some low-power devices, but not servos and other devices connected to the output rail. If servos are used, the pixhawk servo rail should be connected to voltage regulator (alias BEC, battery eliminator circuit) that provides power at 5V to drive the servos. Connect the BEC output to a power pin (+) and ground pin (-) on the rail. Radio Control Warning: Connecting a radio control system to the pixhawk is highly recommended. This ensures that the operator can safety regain control if an auto flight mode malfunctions Connect the output of a radio receiver to the receiver port of the pixhawk using a servo cable. Pixhawk can read CPPM and SBUS directly. The instructions below are specifically for Spektrum and PWM receivers Connect Spektrum satellite receivers to the SPKT/DSM port on Pixhawk 1 or 2.1 Connect PWM receivers with an individual wire for each channel to a PPM encoder first, which converts the signal into CPPM for the Pixhawk Sending RSSI (received signal strength indication) to the Pixhawk allows monitoring of the radio signal strength and helps prevent outflying radio range by accident If the radio receiver has an RSSI output port, connect it to the SBUS port of the Pixhawk. Configure the pixhawk firmware to measure RSSI signal in percentage Telemetry Telemetry is used to monitor vehicle status in flight and send commands to the vehicle, i.e. guide the vehicle to a position on a map, or upload a mission. Connect the output of a telemetry radio to the telem 1 port of the pixhawk using a 6-wire cable. When using a high power radio modem, such as the RFD900 modem, only connect the 4 signal wires to the Pixhawk. Connect the power and ground wires to a separate BEC.","title":"Wiring quickstart"},{"location":"ref/wiring_ref/#mount-and-orient-autopilot","text":"Position the autopilot as close to the vehicle\u2019s center of gravity as possible. Ideally, the autopilot should be mounted in the standard orientation, indicated by the heading mark arrow visible on top and pointing towards the front of the vehicle. To mount the pixhawk in a non-standard orientation, configure the pixhawk firmware to recognize the new orientation. This adjusts sensors readings to realign with the vehicle. The pixhawk should be mounted on vibration absorbing material, which isolates the sensitive sensors in the Pixhawk from vibrations. Soft foam such as 3M Pixhawk Damping Foams, gel pads, and mounting tables with rubber damping balls are effective.","title":"Mount and Orient Autopilot"},{"location":"ref/wiring_ref/#powering-the-autopilot","text":"Connect the output port of a power module to the power port of the Pixhawk with a 6-wire cable. A power module supplies stable and filtered power at 5.4V for the pixhawk, measures battery voltage and/or current drawn from the battery. The power module can supply power to the autopilot, radio receiver, and some low-power devices, but not servos and other devices connected to the output rail. If servos are used, the pixhawk servo rail should be connected to voltage regulator (alias BEC, battery eliminator circuit) that provides power at 5V to drive the servos. Connect the BEC output to a power pin (+) and ground pin (-) on the rail.","title":"Powering the autopilot"},{"location":"ref/wiring_ref/#radio-control","text":"Warning: Connecting a radio control system to the pixhawk is highly recommended. This ensures that the operator can safety regain control if an auto flight mode malfunctions Connect the output of a radio receiver to the receiver port of the pixhawk using a servo cable. Pixhawk can read CPPM and SBUS directly. The instructions below are specifically for Spektrum and PWM receivers Connect Spektrum satellite receivers to the SPKT/DSM port on Pixhawk 1 or 2.1 Connect PWM receivers with an individual wire for each channel to a PPM encoder first, which converts the signal into CPPM for the Pixhawk Sending RSSI (received signal strength indication) to the Pixhawk allows monitoring of the radio signal strength and helps prevent outflying radio range by accident If the radio receiver has an RSSI output port, connect it to the SBUS port of the Pixhawk. Configure the pixhawk firmware to measure RSSI signal in percentage","title":"Radio Control"},{"location":"ref/wiring_ref/#telemetry","text":"Telemetry is used to monitor vehicle status in flight and send commands to the vehicle, i.e. guide the vehicle to a position on a map, or upload a mission. Connect the output of a telemetry radio to the telem 1 port of the pixhawk using a 6-wire cable. When using a high power radio modem, such as the RFD900 modem, only connect the 4 signal wires to the Pixhawk. Connect the power and ground wires to a separate BEC.","title":"Telemetry"}]}